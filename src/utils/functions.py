import numpy as np
import csv
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages


def get_timestamps(filepath, segments = 1000):
    """
    Reads the <filename>_info.txt files generated by IF_bin_to_csv.py script
    and extracts an array of timestamps.

    Args:
        filepath (str) : path to <filename>_info.txt file
                         example filename: 'scope-1-run7_info.txt'
        segments (int) : the total number of segments in a run (1000 is max for 
                         our scope)
    Returns:
        timestamps (ndarray) : numpy array of floats in seconds
    """
    try:
        with open(filepath, 'r') as f:
            lines = f.readlines()

        # Initialise empty timestamps numpy array, expect floats
        timestamps = np.empty(segments, dtype=float)
        count      = 0

        # Loop through all the lines in the file to find 'Time Tags'
        for line in lines:
            if count >= segments:
                break
            if 'Time Tags' in line:
                timestamp = line.split(" = ")[-1]
                timestamp = float(timestamp.split('\'')[1])
                timestamps[count] = timestamp
                count += 1

        # Cut the timestamps array if there are less events than
        # expected segments
        if count < segments:
            timestamps = timestamps[:count]

        return timestamps

    except Exception as e:
        print("Error in 'get_timestamps'")
        print(e)
        return None


def get_waveform(csvfile, xignore=True, negative=True, xconv=1, yconv=1):
    """
    Extracts the x,y data from the csv waveform file.

    Args:
        csvfile (str)   : path to csv file containing waveform
                          example filename: scope-1-run3_segment-1_1.csv
        xignore (bool)  :
        negative (bool) :
        xconv (float)   :
        yconv (float)   :

    Returns:
        data (ndarray) : two dimensional numpy array containt x and y
                         subarrays
    """
    try:
        with open(csvfile, 'r') as f:
            reader = csv.reader(f)
            data   = np.array(list(reader), dtype=float)
            data   = data.T

            data[0] = data[0] * xconv
            data[1] = data[1] * yconv

            if negative == True:
                data[1] = data[1]*(-1)

            if xignore == True:
                data = data[1]

        return data

    except Exception as e:
        print("Error in get_waveform")
        print(e)
        return None


def zero_baseline(wf, cut=0.25):
    """

    Args:
        
    Returns:

    """
    cut_length = int(len(wf)*cut)

    # convert to ndarray if not already
    wf = np.array(wf)

    # take the portion of the wavelength most likely to not contain any peaks
    bl = wf[0:cut_length]

    # calculate its mean
    bl_mean = np.nanmean(bl)

    # subtract this mean from the entire waveform to zero its baseline
    wf = wf - bl_mean

    return wf
    

def get_ingress_idx(wf, thresh=5, cut=0.25):
    """

    Args:

    Returns:

    """
    cut_length = int(len(wf)*cut)

    # convert to ndarray if not already
    wf = np.array(wf)

    # take the portion of the wavelength most likely not to contain any peaks
    bl = wf[0:cut_length]

    # calculate its mean and standard deviation
    bl_mean = np.nanmean(bl)
    bl_std  = np.nanstd(bl)

    # get the voltage threshold above which to calculate index
    thresh_v = bl_mean + thresh*bl_std

    # loop across waveform from the left to get ingress index
    ingress = np.nan
    for idx, elm in enumerate(wf):
        if elm > thresh_v:
            ingress = idx
            break

    return idx




    

