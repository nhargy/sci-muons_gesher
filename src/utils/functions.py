import numpy as np
import csv
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import scipy


def get_timestamps(filepath, segments = 1000):
    """
    Reads the <filename>_info.txt files generated by IF_bin_to_csv.py script
    and extracts an array of timestamps.

    Args:
        filepath (str) : path to <filename>_info.txt file
                         example filename: 'scope-1-run7_info.txt'
        segments (int) : the total number of segments in a run (1000 is max for 
                         our scope)
    Returns:
        timestamps (ndarray) : numpy array of floats in seconds
    """
    try:
        with open(filepath, 'r') as f:
            lines = f.readlines()

        # Initialise empty timestamps numpy array, expect floats
        timestamps = np.empty(segments, dtype=float)
        count      = 0

        # Loop through all the lines in the file to find 'Time Tags'
        for line in lines:
            if count >= segments:
                break
            if 'Time Tags' in line:
                timestamp = line.split(" = ")[-1]
                timestamp = float(timestamp.split('\'')[1])
                timestamps[count] = timestamp
                count += 1

        # Cut the timestamps array if there are less events than
        # expected segments
        if count < segments:
            timestamps = timestamps[:count]

        return timestamps

    except Exception as e:
        print("Error in 'get_timestamps'")
        print(e)
        return None


def get_waveform(csvfile, xignore=True, negative=True, xconv=1, yconv=1):
    """
    Extracts the x,y data from the csv waveform file.

    Args:
        csvfile (str)   : path to csv file containing waveform
                          example filename: scope-1-run3_segment-1_1.csv
        xignore (bool)  :
        negative (bool) :
        xconv (float)   :
        yconv (float)   :

    Returns:
        data (ndarray) : two dimensional numpy array containt x and y
                         subarrays
    """
    try:
        with open(csvfile, 'r') as f:
            reader = csv.reader(f)
            data   = np.array(list(reader), dtype=float)
            data   = data.T

            data[0] = data[0] * xconv
            data[1] = data[1] * yconv

            if negative == True:
                data[1] = data[1]*(-1)

            if xignore == True:
                data = data[1]

        return data

    except Exception as e:
        print("Error in get_waveform")
        print(e)
        return None


def find_baseline(wf_input, width=6, distance=12, prominence=12, roundto = 2, sigma=0.75):
    """

    """
    # Smooth waveform
    wf = scipy.ndimage.gaussian_filter1d(wf_input, sigma=sigma)

    # Prepare mask array of zeros
    mask = np.zeros(len(wf))

    # Already mask waveform after mid-point, which on the scope is t=0,
    # and before an index close to the start of the waveform, to avoid
    # missing semi-peaks.
    mask[int(len(wf)/2)-25:] = 1
    mask[len(wf) - 40:len(wf)] = 1
    mask[0:40] = 1

    # Find peaks
    idxs, dicts = scipy.signal.find_peaks(wf, width=width, distance=distance, prominence=prominence)
    
    # Iterate over found peaks and mask accordingly
    for num, idx in enumerate(idxs):
        lb    = dicts['left_bases'][num]
        rb    = dicts['right_bases'][num]
        width = dicts['widths'][num]

        # width factor
        c = 1.5
        w = int(c*width)

        # Get the left index of peak boundary
        if idx < w:
            left_idx = 0
        else:
            left_idx = idx - w

        # Get the right index of peak boundary
        try:
            test = wf[idx + w]
            right_idx = idx + w
        except:
            right_idx = len(wf)

        # Mask the peak region
        mask[left_idx:right_idx] = 1

    # Perform masking operation
    baseline_wf = np.ma.array(wf, mask=mask)
    
    # Calculate baseline mean and standard deviation
    baseline_mean = np.round(baseline_wf.mean(),roundto)
    baseline_std  = np.round(baseline_wf.std(),roundto)
    
    return baseline_mean, baseline_std, wf, mask


def get_ingress_idx(wf, thresh=5, cut=0.25):
    """

    Args:

    Returns:

    """
    cut_length = int(len(wf)*cut)

    # convert to ndarray if not already
    wf = np.array(wf)

    # take the portion of the wavelength most likely not to contain any peaks
    bl = wf[0:cut_length]

    # calculate its mean and standard deviation
    bl_mean = np.nanmean(bl)
    bl_std  = np.nanstd(bl)

    # get the voltage threshold above which to calculate index
    thresh_v = bl_mean + thresh*bl_std

    # loop across waveform from the left to get ingress index
    ingress = np.nan
    for idx, elm in enumerate(wf):
        if elm > thresh_v:
            ingress = idx
            break

    return idx




    

