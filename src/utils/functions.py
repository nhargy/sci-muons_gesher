import numpy as np
import csv
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import scipy
from scipy import interpolate

def get_timestamps(filepath, segments = 1000):
    """
    Reads the <filename>_info.txt files generated by IF_bin_to_csv.py script
    and extracts an array of timestamps.

    Args:
        filepath (str) : path to <filename>_info.txt file
                         example filename: 'scope-1-run7_info.txt'
        segments (int) : the total number of segments in a run (1000 is max for 
                         our scope)
    Returns:
        timestamps (ndarray) : numpy array of floats in seconds
    """
    try:
        with open(filepath, 'r') as f:
            lines = f.readlines()

        # Initialise empty timestamps numpy array, expect floats
        timestamps = np.empty(segments, dtype=float)
        count      = 0

        # Loop through all the lines in the file to find 'Time Tags'
        for line in lines:
            if count >= segments:
                break
            if 'Time Tags' in line:
                timestamp = line.split(" = ")[-1]
                timestamp = float(timestamp.split('\'')[1])
                timestamps[count] = timestamp
                count += 1

        # Cut the timestamps array if there are less events than
        # expected segments
        if count < segments:
            timestamps = timestamps[:count]

        return timestamps

    except Exception as e:
        print("Error in 'get_timestamps'")
        print(e)
        return None


def get_waveform(csvfile, xignore=True, negative=True, xconv=1, yconv=1):
    """
    Extracts the x,y data from the csv waveform file.

    Args:
        csvfile (str)   : path to csv file containing waveform
                          example filename: scope-1-run3_segment-1_1.csv
        xignore (bool)  :
        negative (bool) :
        xconv (float)   :
        yconv (float)   :

    Returns:
        data (ndarray) : two dimensional numpy array containt x and y
                         subarrays
    """
    try:
        with open(csvfile, 'r') as f:
            reader = csv.reader(f)
            data   = np.array(list(reader), dtype=float)
            data   = data.T

            data[0] = data[0] * xconv
            data[1] = data[1] * yconv

            if negative == True:
                data[1] = data[1]*(-1)

            if xignore == True:
                data = data[1]

        return data

    except Exception:
        return None


def find_baseline(wf, width=6, distance=12, prominence=12, roundto = 2, sigma=0.75):
    """

    Args:
        
    Returns:
        
    """
    # Smooth waveform
    wf_smooth = scipy.ndimage.gaussian_filter1d(wf, sigma=sigma)

    # Prepare mask array of zeros
    mask = np.zeros(len(wf_smooth))

    # Already mask waveform after mid-point, which on the scope is t=0,
    # and before an index close to the start of the waveform, to avoid
    # missing semi-peaks.
    mask[int(len(wf_smooth)/2)-25:] = 1
    mask[len(wf_smooth) - 40:len(wf_smooth)] = 1
    mask[0:40] = 1

    # Find peaks
    idxs, dicts = scipy.signal.find_peaks(wf_smooth, width=width, distance=distance, prominence=prominence)
    
    # Iterate over found peaks and mask accordingly
    for num, idx in enumerate(idxs):
        lb    = dicts['left_bases'][num]
        rb    = dicts['right_bases'][num]
        width = dicts['widths'][num]

        # width factor
        c = 1.5
        w = int(c*width)

        # Get the left index of peak boundary
        if idx < w:
            left_idx = 0
        else:
            left_idx = idx - w

        # Get the right index of peak boundary
        try:
            test = wf[idx + w]
            right_idx = idx + w
        except:
            right_idx = len(wf)

        # Mask the peak region
        mask[left_idx:right_idx] = 1

    # Perform masking operation
    baseline_wf = np.ma.array(wf_smooth, mask=mask)
    
    # Calculate baseline mean and standard deviation
    baseline_mean = np.round(baseline_wf.mean(),roundto)
    baseline_std  = np.round(baseline_wf.std(),roundto)
    
    return baseline_mean, baseline_std, wf_smooth, mask


def get_first_peak(wf, threshold, ROI, min_val=50, smooth=True, sigma=2):
    """
    <description>

    Args:
        
    Returns:
        
    """
    if smooth == True:
        # Smooth waveform
        wf_sm = scipy.ndimage.gaussian_filter1d(wf, sigma=sigma)

    # Starting and end cuts of Region Of Interest
    a = int(ROI[0]); b = int(ROI[1])

    # Cut the waveform
    wf_cut = wf_sm[a:b]

    # Find peaks
    peaks  = scipy.signal.find_peaks(wf_cut, height=threshold, width=6, distance=10, prominence=12)

    # Extract index and value of first peak
    try:
        peak_idx = a + peaks[0][0]
        peak_val = peaks[1]['peak_heights'][0]

        return peak_idx, peak_val

    except:
        return None, None


def get_risetime(t, wf, peak_idx, ROI, fraction=0.12, const = None):
    """
    <Description>

    Args:

    Returns:
    """
    peak_val = wf[peak_idx]
    if const != None:
        rise_val = const
    else:
        rise_val = peak_val * fraction
    

    a = np.argmin(np.abs(t - ROI[0]))
    b = np.argmin(np.abs(t - ROI[1]))
    ROI_idx = (a,b)
    # Generate inverse and reversed interpolated function up to peak
    t_cut    = t[a:peak_idx][::-1]
    wf_cut   = wf[a:peak_idx][::-1]
    f        = interpolate.interp1d(wf_cut, t_cut)

    risetime  = f(rise_val) 

    return risetime
    

    


    

# === PHASING OUT === #

def find_peak(wf, threshold, ROI, sigma=2, min_val=50, div=8):

    # Smooth waveform
    wf_smooth = scipy.ndimage.gaussian_filter1d(wf, sigma=sigma)
    wf_cut    = wf_smooth[ROI[0]:ROI[1]]
    peaks     = scipy.signal.find_peaks(wf_cut, height=threshold, width=6, distance=10, prominence=12) 
    try:
        peak_idx       = ROI[0] + peaks[0][0]
        maxval         = wf_smooth[peak_idx]
        fwhm           = maxval/div
        if fwhm < min_val:
            fwhm = min_val

        egress_idx     = np.where(np.logical_and(wf_cut<fwhm+40, wf_cut>fwhm-40))[0]
        egress_idx     = ROI[0] + np.min(egress_idx)
    except:
        peak_idx       = None
        egress_idx     = None

    return peak_idx, egress_idx
